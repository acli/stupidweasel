#!/usr/bin/perl
# vi: set sw=3 ai sm:
#
# Stupid hack to use Evolution as a mail transport so that we can use mutt if necessary

use strict;
use integer;

use Getopt::Long qw(:config no_auto_abbrev bundling);
use POSIX;

use vars qw( $outbox $sources );
$outbox = "$ENV{HOME}/.local/share/evolution/mail/local/.Outbox";
$sources = "$ENV{HOME}/.config/evolution/sources";

use vars qw( $mtaid );
$mtaid = 'stupidweasel';

use vars qw( $appName $hostname $id );
use vars qw( $tmp $out );

use vars qw( $expected_recipient );
use vars qw( $mode );
use vars qw( %targets );

$appName = $& if $0 =~ /[^\/]+$/;
$hostname = `hostname`; chomp $hostname;

$id = sprintf('%d.%d.%s', time, $$, $hostname);
$tmp = "$outbox/tmp/$id";
$out = "$outbox/cur/$id:2,";	# see spec on cr.yp.to

use vars qw( $debug_p $dry_run_p );
use vars qw( $force_delete_p );
use vars qw( $verbose_p );
use vars qw( %identity );

$force_delete_p = 1;

$SIG{__DIE__} = sub {
   if (-f $tmp) {
      print STDERR "$appName: Removing temporary file $tmp\n";
      unlink $tmp;
   }
};

sub show_version_then_exit () {
   print "$mtaid ($appName) 0.1\n";
   exit(0);
}

sub show_usage_then_exit (;$) {
   my($status) = @_;
   my $h = $status? *STDERR: *STDOUT;
   print $h <<EOF;
usage: $appName [OPTION] ...
Queue a piece of email into Evolution's Outbox.

  -q, --list       list queued emails in outbox
      --delete=ID  delete queued email with ID from outbox
  -t, --add        add email in standard input to outbox (default)
  -d, --debug      enable debugging messages
  -n, --dry-run    do not actually modify the outbox
      --help       show this help and exit
      --version    output version information and exit
EOF
   exit($status);
}

sub looks_like_email_address_p {
   my $it = 1; # assume it's true then disprove it
   for my $s (@_) {
      $it = 0 unless $s =~ /^[^\@]+\@[a-z][-0-9a-z]*(?:\.[a-z][-0-9a-z]*)+$/;
   last unless $it;
   }
   return $it;
}
for my $test (qw( abc@example.com abc.def@u-example.de abc.def-ghi@ocad.on.ca )) {
   die "Test case $test failed" unless looks_like_email_address_p $test;
}
for my $test (qw( abc@ @u-example.de @ foo )) {
   die "Test case $test failed" unless !looks_like_email_address_p $test;
}

sub read_data (;*) {
   my($h) = @_;
   my $it;
   my $section;
   my $state = 0;
   for (;;) {
      my $s = scalar <$h>;
   last unless defined $s;
      chomp $s;
      if ($s =~ /^\s*(?:\s*$|#|;|\/\/)/) {
         ;
      } elsif ($s =~ /^\s*\[(.*?)\]\s*$/) {
         die "$appName: $ARGV:$.: $1: duplicate section\n" if defined $it && defined $it->{$1};
         $section = $1;
      } elsif ($s =~ /^\s*([^=]+?)\s*=\s*(.*?)\s*$/) {
         $it->{$section} = { 'name' => [$section] } unless defined $it && defined $it->{$section};
         $it->{$section}->{$1} = [] unless defined $it->{$section}->{$1};
         push @{$it->{$section}->{$1}}, $2;
      } else {
         die "$appName: $ARGV:$.: sorry, can't parse ($s)\n";
      }
   }
   return $it;
}

sub get_scalar ($$) {
   my($key, $datum) = @_;
   return !(defined $datum && defined $datum->{$key} && defined $datum->{$key}->[0])? undef: $datum->{$key}->[0];
}

sub get_array ($$) {
   my($key, $datum) = @_;
   return !(defined $datum && defined $datum->{$key})? undef: $datum->{$key};
}

sub read_evolution_sources () {
   opendir(SOURCES, $sources) || die "$appName: $sources: $!\n";
   for (;;) {
      my $dirent = readdir SOURCES;
   last unless defined $dirent;
      if ($dirent =~ /\.source$/) {
	 open(DATA, '<', "$sources/$dirent") || die "$appName: $sources/$dirent: $!\n";
	 my $data = read_data DATA;
	 my $mail_account = $data->{'Mail Account'};
	 my $authentication = $data->{'Authentication'};
	 if (defined $mail_account && defined $authentication) {
	    my $uid = get_scalar('IdentityUid', $mail_account);
	    my $email = get_scalar('User', $authentication);
	    if (defined $uid && defined $email) {
	       print STDERR "$appName: $dirent: Detected email ($email) with X-Evolution-Identity ($uid)\n" if $debug_p;
	       $identity{+lc $email} = $uid;
	    }
	 }
	 close DATA;
      }
   }
   closedir SOURCES;
}

sub scan_mbox_file ($$$$) {
   my($filename, $f_header, $f_sep, $f_body) = @_;
   my $state = 0;			# State 0 - From_ or header; 1 - header, separator; 3 - body
   my($from_, @headers);
   my $h;
   if (!$filename || $filename eq '-') {
      ($filename, $h) = ('STDIN', *STDIN);
   } else {
      open MBOX, '<', $filename || die "$filename: $!\n";
      $h = *MBOX;
   }
   for (my $in_body_p = 0;;) {
      my $s = scalar <$h>;
   last unless defined $s;
      if ($state == 0 && $s =~ /^From /s) {
	 $from_ = $s;
	 $state = 1;
      } elsif ($state <= 1) {
	 $state = 1;
	 if ($s eq "\n") {
	    for my $header ($from_, @headers) {
	       &$f_header($header->[0], $filename, $header->[1]);
	    }
	    &$f_sep($s, $filename, $.);
	    $state = 3;
	 } elsif ($s =~ /^\s/s) {
	    die "$filename: $.: Illegal continuation header\n" unless @headers;
	    $headers[$#headers]->[0] .= $s;
	 } else {
	    push @headers, [$s, $.];
	 }
      } elsif ($state == 3) {
	 &$f_body($s, $filename, $.);
      } else {
	 die "$filename: $.: Internal error: Unexpected state $state\n";
      }
   }
   close MBOX;
}

sub display_outbox_summary () {
   my $fmt = "%-30s  %-19s  %-9s  %-24s  %s\n";
   my $n;
   $fmt = "[%s]\nQueued:\t%s\nBy:\t%s\nFrom:\t%s\nTo:\t%s\n\n" if $verbose_p;
   opendir(OUTBOX, "$outbox/cur") || die "$appName: $outbox/cur: $!\n";
   for (my $something_done_p;;) {
      my $dirent = readdir OUTBOX;
   last unless defined $dirent;
      my $candidate = "$outbox/cur/$dirent";
      if (-f $candidate && $dirent =~ /^([^:]+)(?::2,(.*)|$)/) {
	 my($basename, $flags) = ($1, $2);
	 my $deleted = $flags =~ /T/;
	 if (!$deleted) {
	    my($date, $from, $to, $user_agent);
	    scan_mbox_file($candidate, sub {
		     my($s, $filename, $lineno) = @_;
		     if ($s =~ /^From:.*<([^<>]*)>/is || $s =~ /^From:\s*(\S+?)\s*\(.*?\)\s*$/is || $s =~ /^From:\s*(\S+)\s*$/is) {
			$from = $1;
		     } elsif ($s =~ /^To:.*<([^<>]*)>/is || $s =~ /^To:\s*(\S+?)\s*\(.*?\)\s*$/is || $s =~ /^To:\s*(\S+)\s*$/is) {
			$to = $1;
		     } elsif ($s =~ /^Date:\s*(.*?)\s*$/is) {
			$date = $1;
		     } elsif ($s =~ /^(?:User-Agent|X-Mailer):\s*(.*?)\s*$/is) {
			$user_agent = $1;
		     }
		  }, sub { return; }, sub { return; });

	    if (!$something_done_p) {
	       printf $fmt, 'Id', 'Queued', 'By', 'From', 'To' unless $verbose_p;
	       $something_done_p = 1;
	    }
	    if (defined $user_agent && !$verbose_p) {
	       $user_agent =~ s/\([^\(\)]*\)//gs;
	       $user_agent =~ s/ {2,}/ /gs;
	       $user_agent =~ s/\s*\n/\n/gs;
	       $user_agent =~ s/[\/\s].*//s; # cut out any version information, for brevity
	    }
	    my $mtime = (stat $candidate)[9];
	    printf $fmt, $basename, POSIX::strftime('%Y-%m-%d %H:%M:%S', localtime $mtime), $user_agent, $from, $to;
	    $n += 1;
	 }
      }
   }
   closedir OUTBOX;
   printf "$n mail(s) queued in $outbox\n" if $verbose_p;
}

sub remove_queued_email () {
   opendir(OUTBOX, "$outbox/cur") || die "$appName: $outbox/cur: $!\n";
   for (;;) {
      my $dirent = readdir OUTBOX;
   last unless defined $dirent;
      if (-f "$outbox/cur/$dirent" && $dirent =~ /^([^:]+)(?::2,(.*)|$)/) {
	 my($basename, $flags) = ($1, $2);
	 my $deleted = $flags =~ /T/;
	 if (defined $targets{$basename}) {
	    if ($deleted) {
	       print "$appName: $basename: Already in Trash\n";
	    } elsif (!$flags || $force_delete_p) {	# Evolution hasn't seen it yet, or -f used
	       my $target = "$outbox/cur/$dirent";
	       if ($dry_run_p) {
		  print "$appName: Pretending to delete $target\n";
	       } else {
		  unlink $target || warn "$appName: $target: $!\n";
	       }
	    } else {		# Evolution has already seen it
	       my $target = "$basename:2,T$flags";
	       if ($dry_run_p) {
		  print "$appName: Pretending to rename $dirent to $target\n";
	       } else {
		  rename "$outbox/cur/$dirent", "$outbox/cur/$target" || die "$appName: $outbox/cur/$dirent: $!\n";
	       }
	    }
	    delete $targets{$basename};
	 }
      }
   }
   for my $orphan (sort keys %targets) {
      print "$appName: $orphan: Not found in Outbox\n";
   }
   closedir OUTBOX;
}

sub copy_stdin_to_outbox () {
   open(OUTPUT, '>', $tmp) || die "$appName: $tmp: $!\n";
   printf OUTPUT "Received: (from %d\@localhost) by %s (%s) id <%s>; %s\n",
	 $<, $hostname, $mtaid, $id,
	 POSIX::strftime('%a, %e %b %Y %H:%M:%S %z', localtime time);

   my($from, $uid);
   scan_mbox_file('-', sub {
	    my($s, $filename, $lineno) = @_;
	    if ($s =~ /^From:.*<([^<>]*)>/is || $s =~ /^From:\s*(\S+?)\s*\(.*?\)\s*$/is || $s =~ /^From:\s*(\S+)\s*$/is) {
	       $from = $1;
	       $uid = $identity{+lc $from};
	       print STDERR "$appName: Detected from ($from)\n" if $debug_p;
	       die "$appName: $from: Identity not found in evolution config\n" unless defined $uid;
	    }
	    print OUTPUT $s;
	 }, sub {
	    my($s, $filename, $lineno) = @_;
	    die "$appName: From header not detected\n" unless defined $uid;
	    print OUTPUT "X-Evolution-Identity: $uid\n";
	    print OUTPUT $s;
	 }, sub {
	    my($s, $filename, $lineno) = @_;
	    print OUTPUT $s;
	 });
   close OUTPUT;
   print STDERR "$appName: Moving ($tmp) -> ($out)\n" if $debug_p;
   rename $tmp, $out || die "$appName: $out: Rename to \"$out\" failed\n";
}

$mode = $1 if $appName =~ /(q|rm)$/;
GetOptions(
   'f|force'	=> \$force_delete_p,
   'q|list'	=> sub { $mode = 'q'; },
   'delete=s'	=> sub { $mode = 'rm'; $targets{$_[1]} = 0; },
   't|add'	=> sub { $mode = undef; },
   'd|debug'	=> \$debug_p,
   'n|dry-run'	=> \$dry_run_p,
   'v|verbose'	=> \$verbose_p,
   'help'	=> \&show_usage_then_exit,
   'version'	=> \&show_version_then_exit,
) || show_usage_then_exit(1);

if ($mode eq 'rm') {
   for my $arg (@ARGV) {
      $targets{$arg} = 0;
   }
   @ARGV = ();
} elsif (!$mode) {
   for my $arg (@ARGV) {
      die "$appName: $arg: Does not seem to be a valid email address\n" unless looks_like_email_address_p $arg;
      $expected_recipient = $arg;
   }
   @ARGV = ();
}
die "$appName: Unknown options @ARGV\n" if @ARGV && $mode ne 'rm';

($tmp, $out) = ("$id.tmp", "$id.out") if $dry_run_p;
$ENV{LANG} = 'C';

read_evolution_sources;
if ($mode eq 'q') {
   display_outbox_summary;
} elsif ($mode eq 'rm') {
   remove_queued_email;
} else {
   copy_stdin_to_outbox;
}
